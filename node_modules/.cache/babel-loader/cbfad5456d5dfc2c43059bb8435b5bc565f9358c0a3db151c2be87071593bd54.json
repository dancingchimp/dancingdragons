{"ast":null,"code":"// src/components/events/eventHelpers.js\nimport{EVENT_STATUS}from'./eventTypes';// Generate a temporary event token\nexport const generateEventToken=()=>{const array=new Uint8Array(24);crypto.getRandomValues(array);return btoa(String.fromCharCode.apply(null,array)).replace(/\\+/g,'-').replace(/\\//g,'_').replace(/=/g,'');};// Verify event token\nexport const verifyEventToken=(token,eventId)=>{const stored=localStorage.getItem(`event_${eventId}`);if(!stored)return false;try{const{token:storedToken,expiration}=JSON.parse(stored);if(new Date(expiration)<new Date()){localStorage.removeItem(`event_${eventId}`);return false;}return token===storedToken;}catch(e){return false;}};// Store event token with expiration\nexport const storeEventToken=(eventId,token)=>{const expiration=new Date();expiration.setDate(expiration.getDate()+1);// 24-hour expiration\nlocalStorage.setItem(`event_${eventId}`,JSON.stringify({token,expiration:expiration.toISOString()}));};// Handle RSVP response\nexport const handleRSVPResponse=response=>{const{status,token,eventId}=response;if(status===EVENT_STATUS.OPEN){storeEventToken(eventId,token);return{success:true,message:'RSVP confirmed! Check Signal for event details.',type:'success'};}else if(status===EVENT_STATUS.WAITLIST){return{success:true,message:'Added to waitlist. We\\'ll notify you if a spot opens up.',type:'info'};}return{success:false,message:'Unable to process RSVP. Please try again.',type:'error'};};// Clean up expired tokens\nexport const cleanupExpiredTokens=()=>{for(let i=0;i<localStorage.length;i++){const key=localStorage.key(i);if(key.startsWith('event_')){try{const{expiration}=JSON.parse(localStorage.getItem(key));if(new Date(expiration)<new Date()){localStorage.removeItem(key);}}catch(e){localStorage.removeItem(key);}}}};// Run cleanup periodically\nsetInterval(cleanupExpiredTokens,1000*60*60);// Every hour\n// Format event duration\nexport const formatDuration=minutes=>{if(minutes<60)return`${minutes} minutes`;const hours=Math.floor(minutes/60);const remainingMinutes=minutes%60;return remainingMinutes?`${hours} hour${hours>1?'s':''} ${remainingMinutes} minutes`:`${hours} hour${hours>1?'s':''}`;};// Check if event needs weather advisory\nexport const needsWeatherAdvisory=event=>{if(!event||!event.type){return false;}// Only check weather advisory for outdoor events\nreturn['adventure','movement'].includes(event.type)&&event.location&&event.location.terrain&&event.location.terrain!=='Urban';};","map":{"version":3,"names":["EVENT_STATUS","generateEventToken","array","Uint8Array","crypto","getRandomValues","btoa","String","fromCharCode","apply","replace","verifyEventToken","token","eventId","stored","localStorage","getItem","storedToken","expiration","JSON","parse","Date","removeItem","e","storeEventToken","setDate","getDate","setItem","stringify","toISOString","handleRSVPResponse","response","status","OPEN","success","message","type","WAITLIST","cleanupExpiredTokens","i","length","key","startsWith","setInterval","formatDuration","minutes","hours","Math","floor","remainingMinutes","needsWeatherAdvisory","event","includes","location","terrain"],"sources":["/home/elysia/dancingdragons/src/components/events/eventHelpers.js"],"sourcesContent":["// src/components/events/eventHelpers.js\n\nimport { EVENT_STATUS } from './eventTypes';\n\n// Generate a temporary event token\nexport const generateEventToken = () => {\n  const array = new Uint8Array(24);\n  crypto.getRandomValues(array);\n  return btoa(String.fromCharCode.apply(null, array))\n    .replace(/\\+/g, '-')\n    .replace(/\\//g, '_')\n    .replace(/=/g, '');\n};\n\n// Verify event token\nexport const verifyEventToken = (token, eventId) => {\n  const stored = localStorage.getItem(`event_${eventId}`);\n  if (!stored) return false;\n  \n  try {\n    const { token: storedToken, expiration } = JSON.parse(stored);\n    if (new Date(expiration) < new Date()) {\n      localStorage.removeItem(`event_${eventId}`);\n      return false;\n    }\n    return token === storedToken;\n  } catch (e) {\n    return false;\n  }\n};\n\n// Store event token with expiration\nexport const storeEventToken = (eventId, token) => {\n  const expiration = new Date();\n  expiration.setDate(expiration.getDate() + 1); // 24-hour expiration\n  \n  localStorage.setItem(`event_${eventId}`, JSON.stringify({\n    token,\n    expiration: expiration.toISOString()\n  }));\n};\n\n// Handle RSVP response\nexport const handleRSVPResponse = (response) => {\n  const { status, token, eventId } = response;\n  \n  if (status === EVENT_STATUS.OPEN) {\n    storeEventToken(eventId, token);\n    return {\n      success: true,\n      message: 'RSVP confirmed! Check Signal for event details.',\n      type: 'success'\n    };\n  } else if (status === EVENT_STATUS.WAITLIST) {\n    return {\n      success: true,\n      message: 'Added to waitlist. We\\'ll notify you if a spot opens up.',\n      type: 'info'\n    };\n  }\n  \n  return {\n    success: false,\n    message: 'Unable to process RSVP. Please try again.',\n    type: 'error'\n  };\n};\n\n// Clean up expired tokens\nexport const cleanupExpiredTokens = () => {\n  for (let i = 0; i < localStorage.length; i++) {\n    const key = localStorage.key(i);\n    if (key.startsWith('event_')) {\n      try {\n        const { expiration } = JSON.parse(localStorage.getItem(key));\n        if (new Date(expiration) < new Date()) {\n          localStorage.removeItem(key);\n        }\n      } catch (e) {\n        localStorage.removeItem(key);\n      }\n    }\n  }\n};\n\n// Run cleanup periodically\nsetInterval(cleanupExpiredTokens, 1000 * 60 * 60); // Every hour\n\n// Format event duration\nexport const formatDuration = (minutes) => {\n  if (minutes < 60) return `${minutes} minutes`;\n  const hours = Math.floor(minutes / 60);\n  const remainingMinutes = minutes % 60;\n  return remainingMinutes \n    ? `${hours} hour${hours > 1 ? 's' : ''} ${remainingMinutes} minutes`\n    : `${hours} hour${hours > 1 ? 's' : ''}`;\n};\n\n// Check if event needs weather advisory\nexport const needsWeatherAdvisory = (event) => {\n  if (!event || !event.type) {\n    return false\n  }\n  \n  // Only check weather advisory for outdoor events\n  return (\n    ['adventure', 'movement'].includes(event.type) && \n    event.location && \n    event.location.terrain && \n    event.location.terrain !== 'Urban'\n  )\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
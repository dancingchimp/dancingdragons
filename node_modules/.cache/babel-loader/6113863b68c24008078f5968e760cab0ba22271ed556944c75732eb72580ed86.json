{"ast":null,"code":"// File: src/utils/crypto.js\n/**\n * Generates a temporary token for anonymous event participation\n * @returns {string} A unique token\n */export function generateTemporaryToken(){// Generate random bytes\nconst array=new Uint8Array(24);crypto.getRandomValues(array);// Convert to base64 and clean up for URL safety\nreturn btoa(String.fromCharCode.apply(null,array)).replace(/\\+/g,'-').replace(/\\//g,'_').replace(/=/g,'');}/**\n   * Validates a temporary token\n   * @param {string} token - The token to validate\n   * @param {string} eventId - The event ID\n   * @returns {boolean} Whether the token is valid\n   */export function validateTemporaryToken(token,eventId){const stored=localStorage.getItem(`event_${eventId}`);if(!stored)return false;try{const{token:storedToken,expiration}=JSON.parse(stored);const expired=new Date(expiration)<new Date();if(expired){localStorage.removeItem(`event_${eventId}`);return false;}return token===storedToken;}catch(e){return false;}}/**\n   * Cleans up expired tokens\n   */export function cleanupExpiredTokens(){for(let i=0;i<localStorage.length;i++){const key=localStorage.key(i);if(key.startsWith('event_')){try{const{expiration}=JSON.parse(localStorage.getItem(key));if(new Date(expiration)<new Date()){localStorage.removeItem(key);}}catch(e){// Invalid data, remove it\nlocalStorage.removeItem(key);}}}}// Run cleanup periodically\nsetInterval(cleanupExpiredTokens,1000*60*60);// Every hour","map":{"version":3,"names":["generateTemporaryToken","array","Uint8Array","crypto","getRandomValues","btoa","String","fromCharCode","apply","replace","validateTemporaryToken","token","eventId","stored","localStorage","getItem","storedToken","expiration","JSON","parse","expired","Date","removeItem","e","cleanupExpiredTokens","i","length","key","startsWith","setInterval"],"sources":["/home/elysia/dancingdragons/src/utils/crypto.js"],"sourcesContent":["// File: src/utils/crypto.js\n\n/**\n * Generates a temporary token for anonymous event participation\n * @returns {string} A unique token\n */\nexport function generateTemporaryToken() {\n    // Generate random bytes\n    const array = new Uint8Array(24);\n    crypto.getRandomValues(array);\n    \n    // Convert to base64 and clean up for URL safety\n    return btoa(String.fromCharCode.apply(null, array))\n      .replace(/\\+/g, '-')\n      .replace(/\\//g, '_')\n      .replace(/=/g, '');\n  }\n  \n  /**\n   * Validates a temporary token\n   * @param {string} token - The token to validate\n   * @param {string} eventId - The event ID\n   * @returns {boolean} Whether the token is valid\n   */\n  export function validateTemporaryToken(token, eventId) {\n    const stored = localStorage.getItem(`event_${eventId}`);\n    if (!stored) return false;\n    \n    try {\n      const { token: storedToken, expiration } = JSON.parse(stored);\n      const expired = new Date(expiration) < new Date();\n      \n      if (expired) {\n        localStorage.removeItem(`event_${eventId}`);\n        return false;\n      }\n      \n      return token === storedToken;\n    } catch (e) {\n      return false;\n    }\n  }\n  \n  /**\n   * Cleans up expired tokens\n   */\n  export function cleanupExpiredTokens() {\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key.startsWith('event_')) {\n        try {\n          const { expiration } = JSON.parse(localStorage.getItem(key));\n          if (new Date(expiration) < new Date()) {\n            localStorage.removeItem(key);\n          }\n        } catch (e) {\n          // Invalid data, remove it\n          localStorage.removeItem(key);\n        }\n      }\n    }\n  }\n  \n  // Run cleanup periodically\n  setInterval(cleanupExpiredTokens, 1000 * 60 * 60); // Every hour"],"mappings":"AAAA;AAEA;AACA;AACA;AACA,GACA,MAAO,SAAS,CAAAA,sBAAsBA,CAAA,CAAG,CACrC;AACA,KAAM,CAAAC,KAAK,CAAG,GAAI,CAAAC,UAAU,CAAC,EAAE,CAAC,CAChCC,MAAM,CAACC,eAAe,CAACH,KAAK,CAAC,CAE7B;AACA,MAAO,CAAAI,IAAI,CAACC,MAAM,CAACC,YAAY,CAACC,KAAK,CAAC,IAAI,CAAEP,KAAK,CAAC,CAAC,CAChDQ,OAAO,CAAC,KAAK,CAAE,GAAG,CAAC,CACnBA,OAAO,CAAC,KAAK,CAAE,GAAG,CAAC,CACnBA,OAAO,CAAC,IAAI,CAAE,EAAE,CAAC,CACtB,CAEA;AACF;AACA;AACA;AACA;AACA,KACE,MAAO,SAAS,CAAAC,sBAAsBA,CAACC,KAAK,CAAEC,OAAO,CAAE,CACrD,KAAM,CAAAC,MAAM,CAAGC,YAAY,CAACC,OAAO,CAAC,SAASH,OAAO,EAAE,CAAC,CACvD,GAAI,CAACC,MAAM,CAAE,MAAO,MAAK,CAEzB,GAAI,CACF,KAAM,CAAEF,KAAK,CAAEK,WAAW,CAAEC,UAAW,CAAC,CAAGC,IAAI,CAACC,KAAK,CAACN,MAAM,CAAC,CAC7D,KAAM,CAAAO,OAAO,CAAG,GAAI,CAAAC,IAAI,CAACJ,UAAU,CAAC,CAAG,GAAI,CAAAI,IAAI,CAAC,CAAC,CAEjD,GAAID,OAAO,CAAE,CACXN,YAAY,CAACQ,UAAU,CAAC,SAASV,OAAO,EAAE,CAAC,CAC3C,MAAO,MAAK,CACd,CAEA,MAAO,CAAAD,KAAK,GAAKK,WAAW,CAC9B,CAAE,MAAOO,CAAC,CAAE,CACV,MAAO,MAAK,CACd,CACF,CAEA;AACF;AACA,KACE,MAAO,SAAS,CAAAC,oBAAoBA,CAAA,CAAG,CACrC,IAAK,GAAI,CAAAC,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGX,YAAY,CAACY,MAAM,CAAED,CAAC,EAAE,CAAE,CAC5C,KAAM,CAAAE,GAAG,CAAGb,YAAY,CAACa,GAAG,CAACF,CAAC,CAAC,CAC/B,GAAIE,GAAG,CAACC,UAAU,CAAC,QAAQ,CAAC,CAAE,CAC5B,GAAI,CACF,KAAM,CAAEX,UAAW,CAAC,CAAGC,IAAI,CAACC,KAAK,CAACL,YAAY,CAACC,OAAO,CAACY,GAAG,CAAC,CAAC,CAC5D,GAAI,GAAI,CAAAN,IAAI,CAACJ,UAAU,CAAC,CAAG,GAAI,CAAAI,IAAI,CAAC,CAAC,CAAE,CACrCP,YAAY,CAACQ,UAAU,CAACK,GAAG,CAAC,CAC9B,CACF,CAAE,MAAOJ,CAAC,CAAE,CACV;AACAT,YAAY,CAACQ,UAAU,CAACK,GAAG,CAAC,CAC9B,CACF,CACF,CACF,CAEA;AACAE,WAAW,CAACL,oBAAoB,CAAE,IAAI,CAAG,EAAE,CAAG,EAAE,CAAC,CAAE","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}